4.字符流
	计算机并不区分二进制文件与文本文件。所有的文件都是以二进制形式来存储的，因此，从本质上说，所有的文件都是二进制文件。所以字符流是建立在字节流之上的，它能够提供字符层次的编码和解码。例如，在写入一个字符时，Java虚拟机会将字符转为文件指定的编码（默认是系统默认编码），在读取字符时，再将文件指定的编码转化为字符。
	常见的码表如下：
	ASCII		：美国标准信息交换码。 一个字符占一个字节。 用一个字节的 7 位可以表示。 256
	ISO8859-1	：拉丁码表。欧洲码表，用一个字节的 8 位表示。又称 Latin-1(拉丁编码)或“西欧语言”。ASCII 码是包含的仅仅是英文字母，并且没有完全占满 256个编码位置，所以它以 ASCII为基础，在空置的 0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。从而支持德文，法文等。因而它依然是一个单字节编码，只是比ASCII更全面。
	GB2312		：英文占一个字节，中文占两个字节.中国的中文编码表。
	GBK			：中国的中文编码表升级，融合了更多的中文文字符号。
	Unicode		：国际标准码规范，融合了多种文字。所有文字都用两个字节来表示，Java语言使用的就是unicode。
	UTF-8		：英文一个字节，中文三个字节。 最多用三个字节来表示一个字符。（我们以后接触最多的是 iso8859-1、gbk、utf-8）
	查看上述码表后，很显然中文的‘中’在 iso8859-1 中是没有对映的编码的。或者一个字符在2中码表中对应的编码不同，例如有一些字在不同的编码中是有交集的，例如bjg5和 gbk中的汉字简体和繁体可能是一样的，就是有交集，但是在各自码表中的数字不一样。
	ISO8859-1	：一个字节
	GBK			：两个字节包含了英文字符和扩展的中文 ISO8859-1+中文字符
	UTF-8		：万国码，推行的。是 1~3 个字节不等长。英文存的是 1 个字节，中文存的是 3 个字节，是为了节省空间。
4.1.输入字符流
	字符流的体系；
	|Reader 抽象类 ， 所有输出字符流的基类。
		|FileReader 读取文件字符数据的输入字符流.
		|BufferedReader 该类出现的目的：提高读取文件字符数据的效率，对FileReader的功能进行了拓展-->readLine()。 缓冲输入字符流
	方法：
		1.int read()：读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回-1.
		2.int read(char[])：将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回-1.
		3.close():读取字符其实用的是window系统的功能，就希望使用完毕后，进行资源的释放,由于Reader也是抽象类，所以想要使用字符输入流需要使用Reader的实现类。查看API文档。找到了FileReader。
	1.用于读取文本文件的流对象。	2.用于关联文本文件。
	构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。如果该文件不存在会发生FileNotFoundException.
	public static void readTest2() throws IOException{
		//找到目标文件
		File file = new File("F:\\Demo1.java");
		//建立数据的输入通道
		FileReader fileReader = new FileReader(file);
		//建立缓冲字符数组，读取文件的数据
		char[] buf = new char[1024];
		int length = 0;
		while((length = fileReader.read(buf))!=-1){ // read(char[] buf) 读取到的字符数组存储到了字符数组中，返回了
													//本次读取到的字符个数。
			System.out.print(new String(buf,0,length));
		}
		//关闭资源
		fileReader.close();
	}
4.2.输出字符流
	|Writer 抽象类 输出字符流的基类。
		|FileWriter 向文件写出数据输出字符流.
	Writer 中的常见的方法：
		1.write(ch):将一个字符写入到流中。
		2.write(char[]):将一个字符数组写入到流中。
		3.write(String):将一个字符串写入到流中。
		4.flush():刷新流，将流中的数据刷新到目的地中，流还存在。
		5.close():关闭资源：在关闭前会先调用 flush()，刷新流中的数据去目的地。然流关闭。
	发现基本方法和OutputStream类似，有write方法，功能更多一些。可以接收字符串。同样道理Writer是抽象类无法创建对象。查阅API文档，找到了Writer的子类FileWriter.
	FileWriter使用步骤： 
		1.找到目标文件
		2.建立数据的输出通道
		3.写出数据		
		4.关闭资源
	FileWriter 要注意的事项：
		1.new FileWriter(file)的时候 ， 如果目标文件不存在，那么会创建目标文件对象， 如果目标文件已经存在了，那么则不再重新创建。
		2.使用new FileWriter(file)这个构造方法的时候，默认是会先清空文本的数据，然后再写入新的数据。如果需要追加数据则需要使用new FileWriter(file,true)这个构造方法。
		3.使用 FileWriter 的write方法的时候，数据是写入了FileWriter内部维护的字符数组中，如果需要把数据真正的写到硬盘上去，需要调用flush方法或者是close方法,或者是内部维护的字符数组已经满了，这时候也会写到硬盘上。	
	追加文件：默认的FileWriter方法新值会覆盖旧值，想要实现追加功能需要,使用如下构造函数创建输出流append值为true即可。
		FileWriter(String fileName, boolean append)
		FileWriter(File file, boolean append)
	flush方法:如果使用字符输出流,没有调用 close 方法,会发生什么?
	程序执行完毕打开文件,发现没有内容写入.原来需要使用flush方法. 刷新该流的缓冲。为什么只要指定claose方法就不用再flush方法,因为close也调用了flush方法.
4.3.字符流与字节流的区别
	字节流可以拷贝视频和音频等文件，那么字符流可以拷贝这些吗？
	经过验证拷贝图片是不行的。发现丢失了信息，为什么呢？
	计算机中的所有信息都是以二进制形式进行的存储（1010）图片中的也都是二进制在读取文件的时候字符流自动对这些二进制按照码表进行了编码处理，但是图片本来就是二进制文件，不需要进行编码。有一些巧合在码表中有对应，就可以处理，并不是所有的二进制都可以找到对应的。信息就会丢失。所以字符流只能拷贝以字符为单位的文本文件(以ASCII码为例是127个，并不是所有的二进制都可以找到对应的 ASCII，有些对不上的，就会丢失信息。)
4.4.缓冲输入字符流
	查看Reader发现Reader,操作的是字符,我们就不需要进行编码解码操作,由字符流读到二进制,自动进行解码得到字符,写入字符自动编码成二进制.Reader有一个子类BufferedReader。子类继承父类显然子类可以重写父类的方法,也可以增加自己的新方法。例如一次读一行就是常用的操作.那么BufferedReader类就提供了这个方法,可以查看readLine()方法具备 一次读取一个文本行的功能。很显然,该子类可以对功能进行增强。	
	注意：在使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在建立缓冲区对象时，要先有流对象存在.缓冲区的出现提高了对流的操作效率。
原理：其实就是将数组进行封装。
