3.2.IO流简介
	I/O类库中使用“流”这个抽象概念。Java对设备中数据的操作是通过流的方式。
	表示任何有能力产出数据的数据源对象，或者是有能力接受数据的接收端对象。“流”屏蔽了实际的 I/O设备中处理数据的细节。IO流用来处理设备之间的数据传输。设备是指硬盘、内存、键盘录入、网络等。
	Java用于操作流的对象都在IO包中。IO流技术主要用来处理设备之间的数据传输。
	由于Java用于操作流的对象都在IO包中。所以使用IO流需要导包如：import java.io.*;
	IO流的分类:
		流按操作数据类型的不同分为两种：字节流与字符流。
		字节流: 字节流就是用于 读取文件的字节数据的，读取到的数据不会经过任何的处理。
		字符流： 读取到的字节数据还会帮你转换成你看得懂的字符数据，读取的是以字符作单位 的数据。 字符流 = 字节流+ 解码
		流按流向分为：输入流，输出流（以程序为参照物，输入到程序，或是从程序输出）
	什么时候使用输入流什么时候使用输出流？以当前程序作为参照物，数据流入 则使用输入流， 数据流出则使用输出流
3.3.输入字节流
	|InputStream(抽象类)输入字节流的基类。
		|FileInputStream 读取文件数据 的输入字节流
	什么是字节流：计算机中都是二进制数据,一个字节是8 个2进制位.字节可以表示所有的数据,比如文本,音频,视频.图片,都是作为字节存在的.也就是说字节流处理的数据非常多。
	在文本文件中存储的数据是以我们能读懂的方式表示的。而在二进制文件中存储的数据是用二进制形式表示的。我们是读不懂二进制文件的，因为二进制文件是为了让程序来读取而设计的。例如，Java的源程序(.java 源文件)存储在文本文件中,可以使用文本编辑器阅读,但是Java的类(字节码文件)存储在二进制文件中,可以被Java虚拟机阅读。二进制文件的优势在于它的处理效率比文本文件高。
	我们已经知道File对象封装的是文件或者路径属性，但是不包含向（从）文件读（写）数据的方法。为了实现对文件的读和写操作需要学会正确的使用 Java的IO创建对象。
	字节流的抽象基类：
		输入流：java.io.InputStream
		输出流：java.io.OutputStream
	特点：字节流的抽象基类派生出来的子类名称都是以其父类名作为子类名的后缀。
	如：FileInputStream, ByteArrayInputStream 等。
	说明：字节流处理的单元是一个字节，用于操作二进制文件（计算机中所有文件都是二进制文件）
	InputStream有read方法，一次读取一个字节，OutputStream的write方法一次写一个int。发现这两个类都是抽象类。意味着不能创建对象，那么需要找到具体的子类来使用。
	通过查看api文档，找到了FileInputStream类，该类正是我们体验Io流的一个输入流。
	使用FileInputStream 读取文件数据：
		1.找到目标文件
		2.建立数据的输入通道
		3.读取文件的数据
		4.关闭资源
	显然流是Java中的一类对象，要打开流其实就是创建具体流的对象，由于是读取硬盘上的文件，应该使用输入流。所以找到了InputStream类，但是InputStream是抽象类，需要使用它的具体实现类来创建对象就是FileInputStream。通过new调用FileInputStream的构造方法来创建对象。发现FileInputStream的构造方法需要指定文件的来源。查看构造方法，可以接受字符串也可以接受File对象。我们通过构建File对象指定文件路径。
	使用流就像使用水管一样，要打开就要关闭。所以打开流和关闭流的动作是比不可少的。如何关闭流？使用close方法即可，当完成流的读写时,应该通过调用close方法来关闭它,这个方法会释放掉十分有限的操作系统资源.如果一个应用程序打开了过多的流而没有关闭它们,那么系统资源将被耗尽.如何通过流读取内容？
	查找api文档通过read方法，查看该方法，发现有返回值，并且是int类型的，该方法一次读取一个字节（byte）
	1.read方法（）一次读取一个字节,读到文件末尾返回-1.
	仔细查看api文档发现read方法如果读到文件的末尾会返回-1。那么就可以通过read方法的返回值是否是-1 来控制我们的循环读取.
	2.read(byte[] b) 方法。使用缓冲区(关键是缓冲区大小的确定)
	使用read方法的时候，流需要读一次就处理一次，可以将读到的数据装入到字节数组中，一次性的操作数组，可以提高效率。
	问题 1:缓冲区大小?那么字节数组如何定义？定义多大？
		可以尝试初始化长度为 5 的 byte数组。通过read方法，往byte数组中存内容那么该read方法返回的是往数组中存了多少字节。
		测试发现问题，由于数组太小，只装了 5 个字节。而文本的字节大于数组的长度。那么很显然可以将数组的长度定义大一些。例如 1024 个。
	问题三:缓冲区有默认值.
		测试,打印的效果打印出了很多 0，因为数组数组有默认初始化值，所以，我们将数组的数据全部都遍历和出来.现在需要的是取出数组中的部分数据.需要将循环条件修改仔细查看api文档。发现该方法 read(byte[] b)返回的是往数组中存入了多少个字节。就是数组实际存储的数据个数。
	问题一：为什么打印的不是字母而是数字，是字母对应的码值。如何显示字符，强转为 char 即可
	问题二：注意：回车和换行的问题。windows 的换车和换行是"\r\n" 对应码表是 13 和 10 。
	3.使用 read(byte[] b,int off,int len)
	查看 api文档，b显然是一个 byte类型数组，当做容器来使用;off，是指定从数组的什么位置开始存字节;len，希望读多少个
	其实就是把数组的一部分当做流的容器来使用。告诉容器，从什么地方开始装要装多少。
	// 方式四：使用循环配合缓冲数组读取,首选方法
	public static void read4() throws IOException {
		// 找到目标文件
		File file = new File("F:\\a.txt");
		// 建立数据的通道
		FileInputStream fileInputStream = new FileInputStream(file);
		// 读取数据
		byte[] buf = new byte[1024]; // 缓冲字节数组的长度一般都是1024的倍数。
		int length = 0; // 记录本次读取的自己个数。
		while ((length = fileInputStream.read(buf)) != -1) {
			System.out.print(new String(buf, 0, length));
		}
		// 关闭资源(释放资源文件)
		fileInputStream.close();
	}
3.4.输出字节流
	|OutputStream 抽象类，所有输出字节字节流的父类。
		|FileOutputStream 向文件输出数据的输出字节流。
	使用FileOutputStream步骤：
		1.找到目标文件
		2.建立数据的输出通道
	FileOutputStream要注意的细节：
		1.new FileOutputStream 的时候，如果目标文件不存在，那么会先创建目标 文件，然后再写入。
		2.new FileOutputStream(file) 如果目标文件已经存在，那么会先清空 目标文件的数据，然后再写入新的数据.
		3.写入数据的时候如果需要以追加的形式写入，那么需要使用new FileOutputStream(file,true) 这个构造函数。
		4.使用write(int b)方法的时候，虽然参数接受的一个int类型的数据，但是实际上只会把数据的低八位写出，其他24位丢弃。
	使用的就是可以操作文件的字节流对象。OutputStream该类是抽象类，需要使用具体的实现类来创建对象查看API文档，找到了OutputStream的实现类FileOutputStream创建 FileOutputStream流对象,必须指定数据要存放的目的地。通过构造函数的形式。创建流对象时，调用了系统底层的资源。在指定位置建立了数据存放的目的文件。
	00000000-00000000-00000001-10000000(只读取后8位的数)
	写文件的时候发现当文件不存在时，会自动创建一个，但是创建不了多级目录
	write(byte[] b, int off, int len)
	1.使用 write(int b)方法,一次写出一个字节.
		使用 write(int b)方法，虽然接收的是 int类型参数，但是 write的常规协定是：向输出流写入一个字节。要写入的字节是参数 b的八个低位。b的 24个高位将被忽略。
	2.使用 write(byte[] b),就是使用缓冲.提高效率.
	上述案例中的使用了 OutputStram的 write方法，一次只能写一个字节。成功的向文件中写入了内容。但是并不高效，如和提高效率呢？是否应该使用缓冲，根据字节输入流的缓冲原理，是否可以将数据保存中字节数组中。通过操作字节数组来提高效率。查找API文档，在OutputStram类中找到了 write(byte[] b)方法，将 b.length个字节从指定的 byte数组写入此输出流中。
	如何将字节数据保存在字节数组中，以字符串为例，”hello , world” 如何转为字节数组。显然通过字符串的 getBytes方法即可。
	仔细查看 a.txt文本文件发现上述程序每运行一次，老的内容就会被覆盖掉。那么如何不覆盖已有信息，能够往 a.txt里追加信息呢。查看API文档，发现FileOutputStream类中的构造方法中有一个构造可以实现追加的功能 FileOutputStream(File file, boolean append)第二个参数，append - 如果为 true，则将字节写入文件末尾处，而不是写入文件开始处。
	public static void write2() throws IOException {
		// 找到目标文件
		File file = new File("F:\\a.txt");
		// 建立数据的输出通道
		FileOutputStream fileOutputStream = new FileOutputStream(file, true); // 第二个参数为true时写入文件数据就是以追加的形式写入的
		// 准备数据， 把数据写出
		String str = "\r\nhello world";
		// 把字符串转成字节数组
		byte[] buf = str.getBytes();
		// 把字节数组写出
		fileOutputStream.write(buf);
		// 关闭资源
		fileOutputStream.close();
	}