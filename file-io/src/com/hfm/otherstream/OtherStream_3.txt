3.其他流
3.1.序列流
	SequenceInputStream(序列流)：可以把多个输入流串联起来读取，先从第一个开始i读取，然后再下一个....
	序列流是没有读取文件的能力，需要创建FileInputStream对象。
	序列流：也称为合并流
	SequenceInputStream序列流，对多个流进行合并。
	SequenceInputStream表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。
	构造函数：
		SequenceInputStream(InputStream s1, InputStream s2)
		SequenceInputStream(Enumeration<? extends InputStream> e) :初始化新创建 SequenceInputStream通过记住参数，它必须是一个 Enumeration产生对象，它们的运行时类型是 InputStream 。 
	合并两个流：使用构造函数 SequenceInputStream(InputStream s1, InputStream s2)
	合并多个流：SequenceInputStream(Enumeration<? extends InputStream> e),需要传入Enumeration(Vector的迭代器)，如果要传入list集合的Iterator需要定义匿名内部类。
	SequenceInputStream sin = new SequenceInputStream(new Enumeration<InputStream>() {//匿名内部类
		@Override
		public boolean hasMoreElements() {
			return iter.hasNext();
		}
		@Override
		public InputStream nextElement() {
			return iter.next();
		}
	});
package com.edu.cjlu.hfm.otherstream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Vector;
/**
 * 合并流(序列流)
 * @author hfm
 */
public class SequenceStreamTest {
	public static void main(String[] args) {
		File file1 = new File("1.txt");
		File file2 = new File("2.txt");
		File fileOutput = new File("合并.txt");
		FileInputStream fileInputStream1 = null;
		FileInputStream fileInputStream2 = null;
		SequenceInputStream sequenceInputStream = null;
		FileOutputStream fileOutputStream = null;
		try {
			fileInputStream1 = new FileInputStream(file1);
			fileInputStream2 = new FileInputStream(file2);
			sequenceInputStream = new SequenceInputStream(fileInputStream1, fileInputStream2);
			fileOutputStream = new FileOutputStream(fileOutput);
			int length = -1;
			byte[] b = new byte[1024];
			while ((length = sequenceInputStream.read(b)) != -1) {
				System.out.println(new String(b, 0, length));
				fileOutputStream.write(b, 0, length);
			}
			fileOutputStream.flush();
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				sequenceInputStream.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			} finally {
				try {
					fileOutputStream.close();
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
		}
	}
	// 合并多个流
	public static void testSequenceInputStream() throws IOException {
		InputStream in1 = new FileInputStream("c:/a.txt");
		InputStream in2 = new FileInputStream("c:/b.txt");
		InputStream in3 = new FileInputStream("c:/c.txt");
		LinkedHashSet<InputStream> set = new LinkedHashSet<InputStream>();
		set.add(in1);
		set.add(in2);
		set.add(in3);
		final Iterator<InputStream> iter = set.iterator();
		// 传入一个迭代器对象，需要输入Enumeration，需要重写其方法，间接调用其方法，达到相同的效果
		SequenceInputStream sin = new SequenceInputStream(new Enumeration<InputStream>() {// 匿名内部类
			@Override
			public boolean hasMoreElements() {
				return iter.hasNext();
			}
			@Override
			public InputStream nextElement() {
				return iter.next();
			}
		});
		FileOutputStream out = new FileOutputStream("c:/z.txt");
		for (int b = -1; (b = sin.read()) != -1;) {
			out.write(b);
		}
		sin.close();
		out.close();
	}
	// 合并 mp3 文件
	public static void mergeFile() throws IOException {
		File dir = new File("f:\\music");
		File[] files = dir.listFiles(); // 获取到文件夹中的所有子文件
		// 创建一个 Vector 对象存储 FileInputStream 对象
		Vector<FileInputStream> vector = new Vector<FileInputStream>();
		// 遍历数组，
		for (int i = 0; i < files.length; i++) {
			if (files[i].getName().endsWith(".mp3")) {
				vector.add(new FileInputStream(files[i]));
			}
		}
		// 创建一个序列流对象
		SequenceInputStream inputStream = new SequenceInputStream(vector.elements());
		// 创建一个输出流对象
		FileOutputStream fileOutputStream = new FileOutputStream("f:\\晚风.mp3");
		// 边读边写
		byte[] buf = new byte[1024];
		int length = 0;
		while ((length = inputStream.read(buf)) != -1) {
			fileOutputStream.write(buf, 0, length);
		}
		// 关闭资源
		fileOutputStream.close();
		inputStream.close();
	}
	// 切割 mp3
	public static void cutFile() throws IOException {
		File file = new File("F:\\美女\\1.mp3");
		FileInputStream fileInputStream = new FileInputStream(file);
		byte[] buf = new byte[1024 * 1024];
		int length = 0;
		int count = 1;
		while ((length = fileInputStream.read(buf)) != -1) {
			// 每读取一次，则生成一个文件
			FileOutputStream fileOutputStream = new FileOutputStream("F:\\music\\part" + count + ".mp3");
			// 把读取到的数据写出
			fileOutputStream.write(buf, 0, length);
			count++;
			// 关闭资源
			fileOutputStream.close();
		}
		// 关闭资源
		fileInputStream.close();
	}
}
3.2.对象流
	对象的序列化：当创建对象时,程序运行时它就会存在,但是程序停止时,对象也就消失了.但是如果希望对象在程序不运行的情况下仍能存在并保存其信息，将会非常有用，对象将被重建并且拥有与程序上次运行时拥有的信息相同。可以使用对象的序列化。
	对象的序列化： 将内存中的对象直接写入到文件设备中
	对象的反序列化： 将文件设备中持久化的数据转换为内存对象
	基本的序列化由两个方法产生：一个方法用于序列化对象并将它们写入一个流，另一个方法用于读取流并反序列化对象
	ObjectOutputStream(对象的输出流类) : 该类主要是用于把对象数据写出到文件上的。
	ObjectInputStream（对象的输入流类 ） : 把硬盘中的对象数据读取回来。
	对象的输入输出流要注意的实现：
		1.使用 ObjectOutputStream的writeObject方法时候，只能写出实现了Serializable接口的对象。Serializable接口没有任何的方法，这种接口我们称作为标识接口。
		2.对象反序列化的时候创建对象是不会调用构造方法的。
		3.我们把对象写到文件上的时候，文件除了记录对象的一些信息以外，还记录了class的版本号（serialVersionUID）， 这个版本号是通过一个类的类名、 包名、 工程名、成员一起算出的一个id号。
		4.在反序列化的时候，jvm会使用本地class文件算出一个id号与文件记录的id号进行对比，如果不一致，反序列化失败。
		5.如果一个类的成员可能在后期会发生改动，那么可以在序列化之前就指定一个serialVersionUID, 如果一个类一家指定了一个serialVersionUID,那么java虚拟机则不会再计算该class文件的 serialVersionUID了。
		6.如果一个类的某些成员不想被序列化到硬盘上，可以使用关键字transient修饰。
		7.如果一个类的内部维护了另外一个类对象，那么另外一个类也必须 要实现Serializable接口。
	基本的序列化由两个方法产生：一个方法用于序列化对象并将它们写入一个流，另一个方法用于读取流并反序列化对象。
	调用构造方法一定会创建对象，创建对象不一定会调用构造方法。创建对象一定要依赖class文件。
	ObjectOutput:writeObject(Object obj)将对象写入底层存储或流。
	ObjectInput:readObject()读取并返回对象.
	ObjectInputStream:由于上述 ObjectOutput 和 ObjectInput 是接口，所以需要使用具体实现类。
	ObjectOutputStream 被写入的对象必须实现一个接口:Serializable,否则会抛出：NotSerializableException
	ObjectInputStream该方法抛出异常：ClassNotFountException
	ObjectOutputStream和 ObjectInputStream对象分别需要字节输出流和字节输入流对象来构建对象。也就是这两个流对象需要操作已有对象将对象进行本地持久化存储。
package com.edu.cjlu.hfm.otherstream;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
/**
 * 对象流
 * @author hfm
 */
public class ObjectStreamTest {

	public static void main(String[] args) {
		File fileOutput = new File("src/com/edu/cjlu/hfm/otherstream/Person.txt");
		ObjectOutputStreamFTest(fileOutput);
		ObjectInputStreamTest(fileOutput);
	}
	/**
	 * 对象输入，储存到本地，持久化储存
	 * @param fileOutput
	 */
	public static void ObjectOutputStreamFTest(File fileOutput) {
		FileOutputStream fileOutputStream = null;
		ObjectOutputStream objectOutputStream = null;
		Person person = new Person(1, "hfm", "330327");
		try {
			fileOutputStream = new FileOutputStream(fileOutput);
			objectOutputStream = new ObjectOutputStream(fileOutputStream);
			objectOutputStream.writeObject(person);

		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				objectOutputStream.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
	/**
	 *  反序列化，读取硬盘中的对象进到内存中
	 * @param fileInput
	 */
	public static void ObjectInputStreamTest(File fileInput) {
		FileInputStream fileInputStream = null;
		ObjectInputStream objectInputStream = null;
		try {
			fileInputStream = new FileInputStream(fileInput);
			objectInputStream = new ObjectInputStream(fileInputStream);
			Person person = (Person) objectInputStream.readObject();
			System.out.println(person.toString());
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		} catch (IOException e) {
			throw new RuntimeException(e);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				objectInputStream.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
}	
3.3.Serializable
	类通过实现java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。所以需要被序列化的类必须是实现Serializable接口，该接口中没有描述任何的属性和方法，称之为标记接口。如果对象没有实现接口Serializable，在进行序列化时会抛出：NotSerializableException 异常。
	注意：保存一个对象的真正含义是什么？如果对象的实例变量都是基本数据类型，那么就非常简单。但是如果实例变量是包含对象的引用，会怎么样？保存的会是什么？很显然在Java中保存引用变量的实际值没有任何意义，因为Java引用的值是通过JVM的单一实例的上下文中才有意义。通过序列化后，尝试在 JVM 的另一个实例中恢复对象，是没有用处的。
	如下：首先建立一个Dog对象，也建立了一个Collar对象。Dog中包含了一个Collar(项圈)。现在想要保存Dog对象，但是Dog中有一个Collar，意味着保存Dog时也应该保存Collar。假如Collar也包含了其他对象的引用，那么会发生什么？意味着保存一个Dog对象需要清楚的知道Dog对象的内部结构。会是一件很麻烦的事情。Java的序列化机制可以解决该类问题，当序列化一个对象时，Java的序列化机制会负责保存对象的所有关联的对象（就是对象图），反序列化时，也会恢复所有的相关内容。本例中：如果序列化Dog会自动序列化Collar。但是，只有实现了Serializable接口的类才可以序列化。如果只是Dog实现了该接口，而Collar没有实现该接口。会发生什么？
	执行程序，出现了运行时异常。Exception in thread "main" java.io.NotSerializableException: Collar
	所以我们也必须将 Dog中使用的Collar序列化。但是如果我们无法访问Collar的源代码，或者无法使Collar可序列化，如何处理？
	两种解决方法：
		一.继承Collar类，使子类可序列化,但是：如果Collar是final类，就无法继承了。并且，如果Collar引用了其他非序列化对象，也无法解决该问题。
		二.transient:此时就可以使用transient修饰符，可以将Dog类中的成员变量标识为transient,那么在序列化Dog对象时，序列化就会跳过Collar。	
	serialVersionUID：用于给类指定一个 UID。该 UID 是通过类中的可序列化成员的数字签名运算出来的一个 long 型的值。只要是这些成员没有变化，那么该值每次运算都一样。该值用于判断被序列化的对象和类文件是否兼容。如果被序列化的对象需要被不同的类版本所兼容。可以在类中自定义 UID。
	定义方式：static final long serialVersionUID = 42L;
	package com.edu.cjlu.hfm.otherstream;

import java.io.Serializable;
/**
 *	实体类的应该添加实现Serializable接口
 * @author hfm
 *
 */
public class Person implements Serializable {
	private static final long serialVersionUID = 6669510898843320241L;
	private int id;
	private String name;
	private String gmsfhm;
	private int age;
	private double weight;
	private double height;
	public Person() {
		super();
	}
	public Person(int id, String name, String gmsfhm) {
		super();
		this.id = id;
		this.name = name;
		this.gmsfhm = gmsfhm;
	}
	public Person(int id, String name, String gmsfhm, int age, double weight, double height) {
		super();
		this.id = id;
		this.name = name;
		this.gmsfhm = gmsfhm;
		this.age = age;
		this.weight = weight;
		this.height = height;
	}
	@Override
	public int hashCode() {
		return this.gmsfhm.hashCode();
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (age != other.age)
			return false;
		if (gmsfhm == null) {
			if (other.gmsfhm != null)
				return false;
		} else if (!gmsfhm.equals(other.gmsfhm))
			return false;
		if (Double.doubleToLongBits(height) != Double.doubleToLongBits(other.height))
			return false;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (Double.doubleToLongBits(weight) != Double.doubleToLongBits(other.weight))
			return false;
		return true;
	}
	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + ", gmsfhm=" + gmsfhm + ", age=" + age + ", weight=" + weight
				+ ", height=" + height + "]";
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getGmsfhm() {
		return gmsfhm;
	}
	public void setGmsfhm(String gmsfhm) {
		this.gmsfhm = gmsfhm;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public double getWeight() {
		return weight;
	}
	public void setWeight(double weight) {
		this.weight = weight;
	}
	public double getHeight() {
		return height;
	}
	public void setHeight(double height) {
		this.height = height;
	}
}
	
3.4.配置文件类(重点)
Map集合体系
	| Map 接口 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。
		|Hashtable:底层是哈希表数据结构，线程是同步的，不可以存入null键，null值。效率较低，被 HashMap替代。
			|propertise:该类继承自 Hashtable，主要用于读取Java的键值格式的配置文件，比如XML文件，properties文件。
		|HashMap:底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。
			|LinkedHashMap：该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。
		|TreeMap:底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator进行比较排序。return 0，来判断键的唯一性。
		|weekHashMap:以弱键实现的基于哈希表的Map。在WeakHashMap中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，null值和 null键都被支持。
	Properties类继承自Hashtable，如下：
	|java.lang.Object 
		|java.util.Dictionary<K,V> 
			|java.util.Hashtable<Object,Object> 
				|java.util.Properties 
	它提供了几个主要的方法：	
		1．getProperty(String key)，用指定的键在此属性列表中搜索属性。也就是通过参数key，得到 key所对应的value。
		2．load(InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties文件）进行装载来获取该文件中的所有键-值对。以供getProperty(String key)来搜索。
		3．setProperty(String key,String value)，调用Hashtable的方法put。他通过调用基类的put方法来设置键-值对。
		4．store(OutputStream out,String comments)，以适合使用load方法加载到Properties表中的格式，将此Properties表中的属性列表（键和元素对）写入输出流。与load方法相反，该方法将键-值对写入到指定的文件中去。
		5．clear()，清除所有装载的 键-值对。该方法在基类中提供。
	Properties:该集合不需要泛型，因为该集合中的键值对都是String类型。
		1.存入键值对：setProperty(key,value);
		2.获取指定键对应的值：value getProperty(key);
		3.获取集合中所有键元素：Enumeration propertyNames();在jdk1.6版本给该类提供一个新的方法。
			Set<String> stringPropertyNames();
		4.列出该集合中的所有键值对，可以通过参数打印流指定列出到的目的地。
			list(PrintStream);
			list(PrintWriter);例：list(System.out):将集合中的键值对打印到控制台。
			list(new PrintStream("prop.txt")):将集合中的键值对存储到prop.txt文件中。
		5.可以将流中的规则数据加载进行集合，并称为键值对。
			load(InputStream):jdk1.6版本。提供了新的方法。
			load(Reader):
		注意：流中的数据要是"键=值" 的规则数据。
		6.可以将集合中的数据进行指定目的的存储。
			store(OutputStram,String comment)方法。jdk1.6版本。提供了新的方法。
			store(Writer ,String comment):使用该方法存储时，会带着当时存储的时间。
		注意：Properties只加载key=value这样的键值对，与文件名无关，注释使用#	
	Properties类与配置文件
	Map
		|--Hashtable
			|--Properties
	注意：是一个 Map 集合，该集合中的键值对都是字符串。该集合通常用于对键值对形式的配置文件进行操作.
	配置文件：将软件中可变的部分数据可以定义到一个文件中，方便以后更改，该文件称之为配置文件。	
	优势: 提高代码的维护性。
	Properties: 该类是一个Map的子类，提供了可以快速操作配置文件的方法
		load(): 将文件设备数据装载为Map集合数据
		get(key):获取Map中的数据
		getProperty()获取Map中的数据特有方法		
	roperties ----》 配置文件类 属于 Map 集合体系的。
	Properties的作用：
		1.生成配置文件。
		2.读取配置。
	Properties要注意的事项：
		1.往Properties添加数据的时候，千万不要添加非字符串类型的数据，如果添加了非字符串类型的数据，那么properties的处理方式就是进行强制类型转换，强转报错。
		2.如果properties的数据出现了中文字符，那么使用store方法时，千万不要使用字节流，如果使用了字节流，那么默认使用iso8859-1码表进行保存，如果出了中文数据建议使用字符流。
		3.如果修改了properties里面 的数据，一定要重新生成一个配置文件。
package com.edu.cjlu.hfm.otherstream;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

public class PropertiesTest {
	/**
	 * @param args
	 * @throws IOException
	 * @throws FileNotFoundException
	 */
	public static void main(String[] args) throws FileNotFoundException, IOException {
		checkRuntime();
		createProperties();
		loginProperties();
		Properties properties = new Properties();
		properties.setProperty("key1", "value1");
		properties.setProperty("key2", "value2");
		properties.setProperty("key3", "value3");
		properties.setProperty("key4", "value4");
		System.out.println(properties.toString());
		Set<Entry<Object, Object>> set = properties.entrySet();
		Iterator<Entry<Object, Object>> iterator = set.iterator();
		while (iterator.hasNext()) {
			System.out.println(iterator.next().toString());
		}
	}
	/*
	 * 需求：使用 porperites 文件实现本软件只能试用三次，三次之后提示用户购买正版，退出 jvm。
	 */
	public static void checkRuntime() throws IOException, FileNotFoundException {
		// 先检查是否存在配置文件
		File file = new File("src/com/edu/cjlu/hfm/otherstream/runtime.properties");
		if (!file.exists()) {// ，如果不存在，创建配置文件
			file.createNewFile();
		}
		// 创建一个 Properties 对象
		Properties properties = new Properties();
		// 加载配置文件
		properties.load(new FileReader(file));
		// 定义一个变量记录运行的次数
		int count = 0;
		// 如果配置文件记录了运行次数，则应该使用配置文件的运行次数
		String num = properties.getProperty("num");
		if (num != null) {
			count = Integer.parseInt(num);
		}
		// 判断是否已经运行了三次
		if (count == 3) {
			System.out.println("已经到了使用次数，请购买正版！！88");
			System.exit(0);
		}
		count++;
		properties.setProperty("num", count + "");
		System.out.println("你已经运行了" + count + "次，还剩余" + (3 - count) + "次");
		// 重新生成配置文件
		properties.store(new FileWriter(file), "runtime");
	}

	/**
	 * 生产配置文件
	 */
	public static void createProperties() {
		File file = new File("src/com/edu/cjlu/hfm/otherstream/Properties.Properties");
		FileWriter fileWriter = null;
		Properties properties = new Properties();
		properties.setProperty("key1", "value1");
		properties.setProperty("key2", "value2");
		properties.setProperty("key3", "value3");
		properties.setProperty("key4", "value4");
		try {
			fileWriter = new FileWriter(file);
			properties.store(fileWriter, "配置文件");
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				fileWriter.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}

	/**
	 * 配置文件如果有中文需要使用字符流进行文件读取 读取配置文件
	 * @param <E>
	 */
	public static void loginProperties() {
		File file = new File("src/com/edu/cjlu/hfm/otherstream/Properties.Properties");
		Properties properties = new Properties();
		FileReader fileReader = null;
		try {
			fileReader = new FileReader(file);
			properties.load(fileReader);
			Set<Entry<Object, Object>> set = properties.entrySet();
			Iterator<Entry<Object, Object>> iterator = set.iterator();
			while (iterator.hasNext()) {
				System.out.println(iterator.next().toString());
			}
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				fileReader.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
}
		